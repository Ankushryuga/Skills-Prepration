## Practice Docker

**Container**: A docker container image is a lightweight standalone, executable package of software that includes everything needed to run an application.

**Open Container Initiative (OCI)**: "Its an open governance structure for the express purpose of creating open industry standards around container formats and runtimes".

**Hypervisor**: its combination of software and hardware, there are 2 types of hypervisor: 1.Bare Metal(No underlying os)=> that is its directly running on physical h/w.
2. Hosted(sharing resource of physical h/w in separate isolated). 

**Containers**:
1. No dependency conflicts
2. Even better utilization efficiency
3. Small blast radius
4. Even faster startup and shutdown
5. Even faster provisioning & decommissioning
6. Lightweight enough to use in development


## Host can be virtual or physical machine, and containers running on those virtual machines.
To manage all these containers and virual machines **Orchestraion (Kubernetes, Docker Swarm)** introduced to manage them.

## Core of Containers:
1. **Namespaces**: its a mechanism to wrap the global resources in an abstraction that makes it appear to the processes within the namespace that they have their own isolated instance of the global resource.
2. Changes to the global resource are visible to other processes that are members of the namespace, but are invisible to other processes.
  
3. **Control Groups or cgroups**: A linux kernel feature which allow processes to be organized into hierarchical groups whose usage of various types of resources can then be limited and mentioned.

4. **Union Filesystem or Union Mount FileSystems(overlayfs)**: Allows files and directories of separate file systems, known as branches, to be transparently overlaid, forming a single coherent file system, Contnets of directories which have the same path
5. within the merged branches will be seen together in a single merged directory, within the new, virtual filesystem.


**NOTE**: Docker Daemon managing all the docker container and images.

## Docker vs Docker Desktop vs Docker Engine

**Docker Engine**: Docker CLI, Docker APIs, & Docker Daemon.
**Docker Desktop**: GUI interface.



## Practice:
1. copy the postgres 15.1
==> **docker run --env POSTGRES_PASSWORD=1234  --publish 5432:5432 postgres:15.1-alpine**       here we are setting password as environemnt variable and publishing the port 5432 because the image are running on isolated network, so to connect with that isolated network  we are publishing the port 5432 that can be used to connect to this isolated network.

 
## Using 3rd party containers:

Understanding data within containers:
1. By default all data created or modified in containers is ephemeral (it means any data add/modify etc at runtime, if container stoped all those data will be gone).

2. If some data should be present every time a container image is run (e.g. dependency), it should be built into the image itself.

3. If data is generated by the application that needs to be persisted, a volume should be used to store that outside of the ephemeral container filesystem.



## Practice:
**docker run --interactive --tty --rm ubuntu:22.04**    //flag like **--interactive and --tty** are used together get running shell and **--rm flag** means once container  exited not storing stopping.

**docker run --interactive --tty --name my-ubuntu-container ubuntu:22.04** //now it wont thorw the container once stoped or exited. 

**docker ps -a**  //to list all containers.


### WORKING WITH 3rd PARTY CONTAINER:::
Advantage: without installing anything additional, we can use 3rd party container.

## To start docker container:
**docker start my-ubuntu-container=container**: Restart the container
**docker attach my-ubuntu-container**: to attach the shell inside that container.

## Normally we dont go directly in container and do changes,  we want those container always be there when we start the container, and build our own image containing all those dependencies.

**docker build --tag my-ubuntu-image -<<EOF FROM ubuntu:22.04 RUN apt update && apt install iputils-ping --yes EOF**

## Data Produced at Runtime Practice:
**docker run -it --rm ubuntu:22.04**  //short version of **docker run --interactive --tty --rm ubuntu:22.04**

=> mkdir my-data
=> echo "Hello from the contianer!" > /my-data/hello.txt
=> cat my-data/hello.txt
**NOTE**: now if exit or stop then all these changes will be gone.

## To avoid this we can use first option is to **volume**.
**docker volume create my-volume**: 

## Now we can mount the volume into that file system 
**docker run -it --rm --mount source=my-volume, destination=/my-data/ ubuntu:22.04**
Now if exited my-data will be available in my-volume.

## To check where this file is located?
**docker run -it --rm --privileged --pid=host justincormack/nsenter1@sha256:5af0be5e42ebd55eea2c593e4622f810065c3f45bb805eaacf43f08f3d06ffd8**

**cd my-volume**

## Second option is to use bind option

**docker run -it --rm --mount type=bind, source="${PWD}"/my-data, destination=/my-data ubuntu:22.04**




